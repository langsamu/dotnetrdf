using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;

namespace VDS.RDF.Wrapping.Generator;

[Generator]
public class NodePropertyGenerator : IIncrementalGenerator
{
    private const string NodeProperty = "VDS.RDF.Wrapping.Attributes.NodePropertyAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context) =>
        context.RegisterSourceOutput(
            source: context.SyntaxProvider.ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: NodeProperty,
                predicate: IsPartialProperty,
                transform: NodePropertyModel.From),
            action: GenerateSource);

    private static bool IsPartialProperty(SyntaxNode syntaxNode, CancellationToken _) =>
        syntaxNode is PropertyDeclarationSyntax property
        && property.Modifiers.Any(SyntaxKind.PartialKeyword);

    private static void GenerateSource(SourceProductionContext context, NodePropertyModel model) =>
        context.AddSource(
            $"{model.ClassName}.{model.Name}.generated.cs",
            SourceText.From(model.ToString(), Encoding.UTF8));

    private record NodePropertyModel
    {
        private NodePropertyModel(GeneratorAttributeSyntaxContext context)
        {
            if (context.TargetSymbol is not IPropertySymbol propertySymbol)
            {
                throw new ArgumentException("must be property", nameof(context));
            }

            if (context.Attributes.Length != 1)
            {
                throw new ArgumentException("must have single attribute", nameof(context));
            }

            //Debugger.Launch();
            var att = context.Attributes.Where(static x => x.AttributeClass!.ToDisplayString() == NodeProperty).Single();
            if (att.ConstructorArguments[0].Value is not string predicate)
            {
                throw new ArgumentException("must have single attribute", nameof(context));
            }

            var targetSymbol = context.TargetSymbol;

            Name = targetSymbol.Name;
            ClassName = targetSymbol.ContainingType.Name;
            Namespace = targetSymbol.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Replace("global::", ""); // TODO: better
            Accessibility = targetSymbol.DeclaredAccessibility;
            Predicate = predicate;
            ReturnType = propertySymbol.Type.Name;
            Getter = propertySymbol.GetMethod is IMethodSymbol getter ? new MethodModel(getter) : null;
            Setter = propertySymbol.SetMethod is IMethodSymbol setter ? new MethodModel(setter) : null;
        }

        internal static NodePropertyModel From(GeneratorAttributeSyntaxContext context, CancellationToken _) => new(context);

        public string Name { get; }
        public string ClassName { get; }
        public string Namespace { get; }
        public Accessibility Accessibility { get; }
        public string ReturnType { get; }
        public string Predicate { get; }
        public MethodModel? Getter { get; }
        public MethodModel? Setter { get; }

        public override string ToString()
        {
            var accessibility = Accessibility switch
            {
                Accessibility.Private => "private ",
                Accessibility.ProtectedAndInternal => "protected internal ",
                Accessibility.Protected => "protected ",
                Accessibility.Internal => "internal ",
                Accessibility.Public => "public ",
                _ => string.Empty,
            };

            var b = new StringBuilder();

            b.Append($$"""
                // <auto-generated />
                #nullable enable
                using VDS.RDF;
                using VDS.RDF.Wrapping;
                using System;
                
                namespace {{Namespace}};
                
                partial class {{ClassName}}
                {
                    {{accessibility}}partial {{ReturnType}} {{Name}}
                    {

                """);

            if (Getter is not null)
            {
                var getterAccessibility = Getter.Accessibility switch
                {
                    Accessibility.Private => "private ",
                    Accessibility.ProtectedAndInternal => "protected internal ",
                    Accessibility.Protected => "protected ",
                    Accessibility.Internal or Accessibility.Friend => "internal ",
                    _ => string.Empty,
                };
                b.Append($$"""
                        {{getterAccessibility}}get => this.Singular("{{Predicate}}", {{ReturnType}}.Wrap);

                """);
            }

            if (Setter is not null)
            {
                var setterAccessibility = Setter.Accessibility switch
                {
                    Accessibility.Private => "private ",
                    Accessibility.ProtectedAndInternal => "protected internal ",
                    Accessibility.Protected => "protected ",
                    Accessibility.Internal or Accessibility.Friend => "internal ",
                    _ => string.Empty,
                };

                b.Append($$"""
                        {{setterAccessibility}}set => this.OverwriteNullable("{{Predicate}}", value);

                """);
            }

            b.Append($$"""
                    }
                }
                #nullable restore
                """);

            return b.ToString();
        }
    }

    private record MethodModel
    {
        public Accessibility Accessibility { get; }

        internal MethodModel(IMethodSymbol symbol)
        {
            Accessibility = symbol.DeclaredAccessibility;
        }
    }
}
