using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using System.Threading;

namespace VDS.RDF.Wrapping.Generator;

[Generator]
public class NodeGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterSourceOutput(
            source: context.SyntaxProvider.ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: "VDS.RDF.Wrapping.Attributes.NodeAttribute",
                predicate: IsPartialClass,
                transform: NodeModel.From),
            action: GenerateSource);
    }

    private static bool IsPartialClass(SyntaxNode syntaxNode, CancellationToken _) =>
        syntaxNode is ClassDeclarationSyntax property
        && property.Modifiers.Any(SyntaxKind.PartialKeyword);

    private static void GenerateSource(SourceProductionContext context, NodeModel model) =>
    context.AddSource(
        $"{model.ClassName}.generated.cs",
        SourceText.From(model.ToString(), Encoding.UTF8));

    private record NodeModel
    {
        private NodeModel(GeneratorAttributeSyntaxContext context)
        {
            var typeSymbol = (ITypeSymbol)context.TargetSymbol;

            ClassName = typeSymbol.Name;
            Namespace = typeSymbol.ContainingNamespace.ToDisplayString().Replace("global::", "");
            Base = typeSymbol.BaseType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        }

        internal static NodeModel From(GeneratorAttributeSyntaxContext context, CancellationToken _) => new(context);

        public string ClassName { get; set; }
        public string Namespace { get; set; }
        public string? Base { get; set; }

        public override string ToString()
        {
            var baseClass = Base == "object" ? " : GraphWrapperNode" : string.Empty;
            var tool = typeof(NodeGenerator).FullName;
            var version = typeof(NodeGenerator).Assembly.GetName().Version;

            // TODO: `new Wrap` only if needed or suppress
            return $$"""
                // <auto-generated />
                #nullable enable
                using System.CodeDom.Compiler;
                using VDS.RDF;
                
                namespace {{Namespace}};
                
                partial class {{ClassName}}{{baseClass}}
                {
                    [GeneratedCode("{{tool}}", "{{version}}")]
                    protected {{ClassName}}(INode node, IGraph graph) : base(node, graph) { }

                    [GeneratedCode("{{tool}}", "{{version}}")]
                    internal static new {{ClassName}} Wrap(INode node, IGraph graph) => node switch
                    {
                        {{ClassName}} { Graph: var otherGraph } same when ReferenceEquals(otherGraph, graph) => same,
                        _ => new(node, graph),
                    };

                    [GeneratedCode("{{tool}}", "{{version}}")]
                    internal static new {{ClassName}}? Wrap(GraphWrapperNode? node) => node switch
                    {
                        null => null,
                        {{ClassName}} same => same,
                        _ => Wrap(node, node.Graph)
                    };
                }
                #nullable restore
                """;
        }
    }
}
